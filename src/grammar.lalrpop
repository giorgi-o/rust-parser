grammar;

use crate::grammar_ast::{Region, Function, Variable, Statement, Expr};

// Define the top-level structure with a region containing functions
pub Region: Region = {
    "<Keyword, region>" <name:Identifier> "<Lcur, {>" <functions:Function+> "<Rcur, }>" =>
        Region { name, functions }
};

// Define a function with a parameter list and a body
Function: Function = {
    "<Keyword, function>" <name:Identifier> "<Lpar, (>" <params:Parameters> "<Rpar, )>" "<Lcur, {>" <body:StmtList> "<Rcur, }>" =>
        Function { name, params, body }
};

// Define parameters as a comma-separated list
Parameters: Vec<Variable> = {
    => Vec::new(),
    
    <param:Parameter> => vec![param],
    
    <mut params:Parameters> "<Comma, ,>" <param:Parameter> => {
        params.push(param);
        params
    }
};

// Define a single parameter
Parameter: Variable = {
    <name:Identifier> => Variable {
        name,
        var_type: crate::grammar_ast::Type::Int32
    }
};

// Statement list with proper handling of empty bodies
StmtList: Vec<Statement> = {
    <statements:(<Stmt>)+> => statements,  // Requires at least one Stmt
    => Vec::new(),  // Allows for an empty StmtList
};


// Individual statement
Stmt: Statement = {

    "<Keyword, return>" <expr:Expr> "<Semi, ;>" => Statement::Return(expr),
    "<Keyword, let>" <name:Identifier> "<Operator, =>" <expr:Expr> "<Semi, ;>" => Statement::Let(name, expr),
    <expr:Expr> "<Semi, ;>" => Statement::Experssion(expr)

   
    // Add other statement types here
};


// Define an expression
Expr: Expr = {

    Number => Expr::Number(<>),

  

   // r"<Number, ([0-9]+)>" => Expr::Number(<>.parse().unwrap()),

    r#"<StringLiteral, "([^"]*)">"# => Expr::StringLiteral(<>.to_string()),
    
    <name:Identifier> "<Lpar, (>" <args:ExprList> "<Rpar, )>" => Expr::Call(name, args),

    <name:Identifier> => Expr::Variable(name),
};

condition: 

ExprList: Vec<Expr> = {
    => Vec::new(),
    <expr:Expr> => vec![expr],
    <mut exprs:ExprList> "<Comma, ,>" <expr:Expr> => {
      exprs.push(expr);
      exprs
    }
  }
// Match identifiers generically
Identifier: String = r"<Identifier, [a-zA-Z_][a-zA-Z0-9_]*>" => <>.to_string();

Number: i32 = {
    r"<Number, ([0-9]+)>" => <>.split(',').nth(1).unwrap().trim().trim_end_matches('>').parse().unwrap()
};