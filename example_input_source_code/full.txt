region DataManagement {
    // Allocate a block of memory of customizable size
    function allocate(size) {
        let buffer = allocateMemory(size);   // Allocate memory of 'size' bytes
        return buffer;
    }
    // Free a memory block given a pointer
    function free(ptr) {
        freeMemory(ptr);   // Deallocate the memory at 'ptr'
        return 0;
    }
    // Borrow a memory block if it hasn't been freed
    function borrow(ptr) {
        if isMemoryFreed(ptr) {
            return -1;   // Error if trying to use freed memory
        }
        return ptr;   // Otherwise return the pointer
    }

    // A customizable function to allocate and use a block of memory
    function processStream(streamSize ) { //NOTE: WE ONLY TKAE ONE PARAMTER
        blocksize= 10
        let streamPtr = allocate(streamSize);   // Allocate memory for the stream
        let blocks = [];   // Create an empty list to store block pointers

        // Divide the stream into blocks and process them
        for (let i = 0; i < streamSize; i = i + blockSize) {
            let blockPtr = borrow(streamPtr + i);   // Borrow part of the memory
            blocks.push(blockPtr);   // Process and store the block pointer
        }
        return blocks;
    }
}